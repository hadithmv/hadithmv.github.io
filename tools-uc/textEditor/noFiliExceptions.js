// List of words where ނ/ރ without fili is allowed
// not that these words are trimmed, and only include the first 2 characters immediately before and after the husnuunu/raa, to keep the list small. actual full worded list would be 4344 words
// the shortened list here is 586
// export const noFiliExceptions = [
window.noFiliExceptions = [
  "ގަނޑު",
  "ގަނޑަ",
  "ހަނކާ",
  "ހަނކި",
  "ހަނދަ",
  "ހަނދާ",
  "ހަނދި",
  "ހަނދު",
  "ލަނގަ",
  "ހަނދެ",
  "ހަނދޭ",
  "ހަނދޮ",
  "ހަނގާ",
  "ހަނގު",
  "ހަނޑޫ",
  "ހަނޑަ",
  "ހަނޑު",
  "ކަނޑާ",
  "ކެނޑު",
  "ހަނޑެ",
  "އަނބު",
  "ހިނދު",
  "ކުނޑި",
  "އެނބު",
  "އެނބެ",
  "ކަނޑަ",
  "ގޮނޑި",
  "ލެނބެ",
  "ކާނށި",
  "ލުނބޯ",
  "ގަނޑޮ",
  "ރާނޑާ",
  "ހިނގު",
  "ބޮނޑި",
  "ދަނޑި",
  "ރޮނގު",
  "ޅަނގު",
  "ލާނފަ",
  "އިނގި",
  "ބަނޑާ",
  "ބަނޑު",
  "ކަނޑި",
  "ލޮނދި",
  "ލަނޑަ",
  "ލަނޑާ",
  "ޕުނޑަ",
  "ޕުނޑި",
  "ޕުނޑު",
  "ޕޮނޑި",
  "ކެނބު",
  "އަނގޮ",
  "ރިނގު",
  "ޅަނދު",
  "ރަނބި",
  "ތުނޑު",
  "ފުނޑަ",
  "ދަނޑީ",
  "ރަނޑަ",
  "ހާނ",
  "ހާނބަ",
  "ހާނބު",
  "ހާނދި",
  "ހާނދީ",
  "ހާނދު",
  "ބޮނގަ",
  "ބޮނގު",
  "ލޯނޓި",
  "ކަނޑު",
  "ށުނގަ",
  "ކަނދު",
  "ކަނދާ",
  "ރުނދު",
  "ރުނބު",
  "ކެނޑި",
  "ހިނބު",
  "ހިނބޫ",
  "ހިނބެ",
  "ހިނބޮ",
  "ހިނދި",
  "ހިނދޫ",
  "ހިނދޮ",
  "ހިނގަ",
  "ހިނގާ",
  "ބިނގާ",
  "ގެނޑި",
  "ކަނދަ",
  "ކަނދި",
  "ބަނޑޮ",
  "ކަނދެ",
  "ގެނހެ",
  "ކަނދޮ",
  "ބޮނދެ",
  "އިނގު",
  "ޅަނގި",
  "ކަނޑޫ",
  "ތަނބެ",
  "ރަނގަ",
  "ގަނޑެ",
  "ލަނބަ",
  "ލަނބު",
  "ރިނދަ",
  "ހީނ",
  "ހީނހީ",
  "ހީނލު",
  "ހީނގަ",
  "ހީނސަ",
  "އުނގު",
  "ހުނޑި",
  "ހުނ",
  "ހުނބު",
  "ހުނބޮ",
  "ހުނވަ",
  "ހުނގު",
  "ހުނގޫ",
  "ހުނސް",
  "ރަނދި",
  "ރެނދި",
  "ސުނބެ",
  "ޅުނބު",
  "ޓާނޑާ",
  "ލަނދަ",
  "ތަނޑި",
  "ވަނދަ",
  "ވަނދު",
  "ގަނދަ",
  "ވަނދެ",
  "ވަނދޮ",
  "ރޮނޑު",
  "އަނދު",
  "އުނޓު",
  "ޔާނގު",
  "އޮނޓާ",
  "ގަނދެ",
  "ހޫނ",
  "ހޫނހޫ",
  "ހޫނކު",
  "ހެނބެ",
  "ހެނދި",
  "ހެނދު",
  "ހެނތެ",
  "ހެނގަ",
  "ހެނގާ",
  "ހެނޑު",
  "ހެނޑެ",
  "ހޭނ",
  "ހޮނދަ",
  "ހޮނދި",
  "ހޮނދު",
  "ހޮނޑަ",
  "ހޮނޑާ",
  "ހޮނޑު",
  "ހޮނޑެ",
  "ހޮނޑޮ",
  "ރޮނގަ",
  "ކޮނޑު",
  "ސިނގު",
  "ކެނބެ",
  "އުނބު",
  "ޒޯނގު",
  "އެނގޭ",
  "ކެނބަ",
  "ބަނދަ",
  "އަނގު",
  "އުނދު",
  "ބޮނދަ",
  "ޔަނދު",
  "ހިނދޭ",
  "ރުނގު",
  "ބަނދި",
  "ފަނޑި",
  "ދޮނގެ",
  "ނޭނގު",
  "އުނދަ",
  "ގުނބޯ",
  "ހަނބު",
  "ޅިނދު",
  "ށަނގޫ",
  "އަނހާ",
  "ހާނސަ",
  "އަނހި",
  "އަނބި",
  "ކަނބަ",
  "އަނބޮ",
  "އަނބޯ",
  "އަނމާ",
  "އަނދަ",
  "އަނދި",
  "އަނދެ",
  "އަނދޮ",
  "އަނގަ",
  "ފިނދު",
  "އަނގި",
  "އަނގޫ",
  "ބަނޑަ",
  "ކުނބު",
  "ޔަނބޯ",
  "ރަނގު",
  "ތަނބު",
  "އެނދާ",
  "ރެނދު",
  "ބިނދު",
  "ބަނޑޭ",
  "ރުނބާ",
  "ލެނބު",
  "ހުނއް",
  "ކަނބި",
  "އާނ",
  "އާނހު",
  "ހުނތް",
  "އާނބަ",
  "އާނޅެ",
  "އާނޅޭ",
  "އާނކި",
  "އާނއެ",
  "އާނފަ",
  "އާނދޮ",
  "އާނގަ",
  "އާނގު",
  "ގަނޑާ",
  "ކޮނޑި",
  "ށަނގަ",
  "ށަނގޮ",
  "އިނބަ",
  "އިނބި",
  "އިނބު",
  "އިނބޭ",
  "އިނދަ",
  "އިނދު",
  "އިނދެ",
  "އިނދޯ",
  "އިނގޭ",
  "އުނހު",
  "ހުނހޫ",
  "އުނހޫ",
  "އުނހް",
  "އުނބަ",
  "އުނބެ",
  "އުނދެ",
  "އުނދޭ",
  "އުނދޯ",
  "އުނގަ",
  "އުނގެ",
  "އުނޑަ",
  "ރަނދު",
  "ޅަނބޮ",
  "ނޭނގޭ",
  "އެނދު",
  "ޑަނގަ",
  "އޫނ",
  "އޫނއެ",
  "ހެނޑަ",
  "ދަނޑު",
  "އެނހި",
  "އެނހެ",
  "ސެނބު",
  "އެނބޫ",
  "އެނދަ",
  "އެނދި",
  "އެނގަ",
  "އެނގި",
  "އެނގު",
  "އެނގެ",
  "ގޭނޑި",
  "ތުނޑި",
  "ރާނޑެ",
  "ހާނޑޮ",
  "އޭނ",
  "އޭނހި",
  "އޭނދަ",
  "ށަނގު",
  "އޮނބަ",
  "އޮނބޮ",
  "އޮނޓެ",
  "ބެނޑި",
  "އޮނބެ",
  "ކޫނޑު",
  "ދޯނގި",
  "ބޮނޑޮ",
  "ށެނގަ",
  "ދަނބަ",
  "ދަނބާ",
  "ދަނބި",
  "ދަނބު",
  "ދަނބޮ",
  "ދަނގަ",
  "ދަނގެ",
  "ފަނގު",
  "ދަނޑޮ",
  "ކެނޑެ",
  "ބަނދެ",
  "ބޭނޑި",
  "ގަނދު",
  "ގަނދޮ",
  "ކަނޑީ",
  "ދަނގު",
  "ދާނޑަ",
  "ދާނޑި",
  "ދާނޑު",
  "ވޭނޑު",
  "ރޮނޑޮ",
  "ގޮނޑޮ",
  "އެނދެ",
  "ރެނޑި",
  "ގޮނޑު",
  "ދުނބު",
  "ދުނގެ",
  "ކޫނޑި",
  "ކެނދި",
  "ކިނދި",
  "ރަނގި",
  "ތުނބު",
  "އޮނބާ",
  "ދޮނގު",
  "ރީނދޫ",
  "ކަނބު",
  "ރުނބަ",
  "ލަނގު",
  "ޅަނބު",
  "ލިނބޯ",
  "ހާނޑާ",
  "ފަނހާ",
  "ފަނދި",
  "ފަނދު",
  "ފަނޑު",
  "ފަނޑޮ",
  "ތާނގަ",
  "ބޮނދި",
  "ތުނޑަ",
  "ތުނޑެ",
  "އިނދޭ",
  "ފަނދަ",
  "ފަނދޮ",
  "ރަނޑި",
  "ސަނގު",
  "ތަނގު",
  "ބަނޑި",
  "ލުނބު",
  "ލުނބެ",
  "{ނ}",
  "{ރ}",
  "ފާނދޫ",
  "ސަނދު",
  "ބަނބު",
  "ފިނދަ",
  "ފިނދި",
  "ފިނދޮ",
  "ފިނޑި",
  "ފިނޑު",
  "ބިނދެ",
  "ގޯނބި",
  "ލުނދު",
  "ފީނދި",
  "ށުނގު",
  "ފުނޑާ",
  "ފުނޑި",
  "ފުނޑު",
  "ޅުނގު",
  "ގުނޑި",
  "ހެނބު",
  "ފެނޑު",
  "ލަނދި",
  "ތާނގީ",
  "ރެނޑު",
  "ގަނޑި",
  "ބޮނބި",
  "ހަނޑާ",
  "ހަނޑި",
  "ހޮނޑި",
  "ތަނޑު",
  "ރަނތް",
  "ގަނބަ",
  "ގަނބާ",
  "ގަނބި",
  "ގަނބު",
  "ގަނދާ",
  "ގަނގު",
  "ގަނޑޯ",
  "ރަނބު",
  "ވަނޑޮ",
  "ފިނދެ",
  "ގިނބު",
  "ގިނދާ",
  "އަނޑާ",
  "ރިނދާ",
  "ގުނބު",
  "ގުނގު",
  "ރަނދަ",
  "ގެނބި",
  "ގެނބު",
  "ކެނދު",
  "ލާނބު",
  "ގޮނބި",
  "ގޮނދާ",
  "ގޮނގު",
  "ގޮނޑީ",
  "ގޮނޑެ",
  "ގޮނޓެ",
  "ގޮނދު",
  "ރީނދި",
  "ގޯނޑި",
  "ރަނބެ",
  "ލަނބޮ",
  "ލަނގި",
  "ލަނގެ",
  "ލަނގޮ",
  "ލަނޑު",
  "ލަނޑެ",
  "ލަނޑޮ",
  "ގުނޑު",
  "ލާނށި",
  "ލާނބޮ",
  "ލާނދާ",
  "ލާނދެ",
  "ބޮނދު",
  "ކާނއޭ",
  "ލިނބޮ",
  "ލުނބޮ",
  "ރޮނގެ",
  "ލެނގި",
  "ލެނގު",
  "ކޮނޑަ",
  "ލޮނދަ",
  "ލޮނދެ",
  "ލޮނދޮ",
  "ލޯނގު",
  "ޅަނދޮ",
  "ޅާނބު",
  "ޅޭނބޫ",
  "ޅޮނގު",
  "ފޮނޑަ",
  "ބޮނޑު",
  "ތުނބި",
  "ކަނބާ",
  "ކަނބޮ",
  "ކަނބޯ",
  "ކަނދީ",
  "ކަނޑޮ",
  "ކަނޑޯ",
  "ކަނޓަ",
  "ކެނޑޭ",
  "ޅަނގާ",
  "ބޮނޑަ",
  "ތުނބޮ",
  "ޔަނބު",
  "ލާނގެ",
  "ކާނހަ",
  "ކާނހި",
  "ކާނލޯ",
  "ކާނޓު",
  "ކިނބި",
  "ކިނބޫ",
  "ކިނދާ",
  "ކިނދު",
  "އަނބަ",
  "ކީނދި",
  "ކީނދު",
  "ކުނބޯ",
  "ރެނގި",
  "ޅަނދި",
  "ސަނދަ",
  "ކޫނޑެ",
  "ކެނބި",
  "ރަނގާ",
  "ރެނބެ",
  "ކޭނހި",
  "ހުނބަ",
  "ކޮނޑާ",
  "ކޮނޑެ",
  "ކޮނޑޮ",
  "ތަނބި",
  "ބޭނގު",
  "ތަނބަ",
  "ތަނބާ",
  "ތަނބޮ",
  "ޅިނގު",
  "ތާނޑާ",
  "ކާނށެ",
  "ޓަރ",
  "ތިނބި",
  "ނޭނގި",
  "ތުނބަ",
  "ތުނބާ",
  "ތުނބެ",
  "ތުނޑާ",
  "ތުނޑޫ",
  "ކުނބަ",
  "ތޫނބި",
  "ތެނބެ",
  "ކުނބާ",
  "ތޮނގި",
  "ތޯނޑު",
  "ޗަނބޭ",
  "ޗާނދަ",
  "ޖަނބު",
  "ޖަނގި",
  "ޖޭނބު",
  "ޓިނބު",
  "ސަނގަ",
  "ސަނޑޫ",
  "ޅަނގަ",
  "ސިނގި",
  "ސިނގެ",
  "ލިނބު",
  "ކާނދި",
  "ލަނބޯ",
  "އެނގާ",
  "ރީނބު",
  "ރެނދަ",
  "ދަނހަ",
  "ހިނދެ",
  "އަނދާ",
  "މީނދަ",
  "ސަނދި",
  "ސަނތި",
  "ޓަނގަ",
  "ހަނކެ",
  "ހޭނވަ",
  "ރަނގޮ",
  "ލާނޑާ",
  "ވަނގާ",
  "ވަނޓެ",
  "ރަނޑު",
  "ވެނދޮ",
  "ކުނބެ",
  "އަނހަ",
  "ވިނގު",
  "ހާނޑެ",
  "ހުނޅު",
  "ވޭނޑި",
  "ޑަނޑޫ",
  "ޑިނގާ",
  "ރަނބަ",
  "ރަނބާ",
  "ރަނބޯ",
  "ރަނޑާ",
  "ރަނޑޫ",
  "ރަނޑެ",
  "ގަރ",
  "ރާނބާ",
  "ރިނބި",
  "ރިނބު",
  "ޕިނޑި",
  "ރީނބޫ",
  "ރީނދު",
  "ރީނދެ",
  "ރީނތު",
  "ރުނޑި",
  "ރެނދެ",
  "ރޭނދާ",
  "ރޮނގާ",
  "ރޮނގޮ",
  "ރޮނޑި",
  "ރޮނޑެ",
  "ރޯނގާ",
  "ބަނހީ",
  "ބަނބަ",
  "ބަނދާ",
  "ބަނގަ",
  "ބަނގު",
  "ބަނގެ",
  "ބަނޑީ",
  "ޅިނދެ",
  "ޅިނދި",
  "ބާނށި",
  "ބާނބު",
  "ބާނދީ",
  "ބާނޓު",
  "ބިނބި",
  "ބެނދެ",
  "ބޭނޑަ",
  "ބޭނޑު",
  "ބޮނބެ",
  "ބޮނދާ",
  "ބޮނދޮ",
  "ބޮނގޮ",
  "ބޮނޑެ",
  "ބޯނށި",
  "ބޯނބި",
  "ބޯނއެ",
  "ބޯނޑި",
  "ބޯނޓި",
  "ކެނދޮ",
  "ޖުނގޯ",
  "ނާނދާ",
];

/*

give me all the dhivehi diacritics in a list, just the characters themselves

Here are all the Dhivehi (Thaana script) diacritics:
ަ
ާ
ި
ީ
ު
ޫ
ެ
ޭ
ޮ
ޯ
ް
These diacritics (called fili in Dhivehi) are used to indicate vowel sounds when combined with consonant letters in the Thaana script.

...

what is the javascript regex range for them

The JavaScript regex range for all Dhivehi diacritics is:
[\u0EB0-\u0EBF]

This Unicode range captures all the Thaana diacritics (ަ ާ ި ީ ު ޫ ެ ޭ ޮ ޯ ް).

If you need to use it in a pattern, you could use something like:
const dhivehiDiacriticsPattern = /[\u0EB0-\u0EBF]/g;

This would allow you to test for or match any Dhivehi diacritic character in a string.

...

write me js regex to, find all instances of
ނ
ރ
not being immediately followed by a dhivehi diacritic
but rather rather those two characters have no dhivehi diacritic on them at all

Here's a JavaScript regex to find all instances of ނ or ރ that aren't immediately followed by a Dhivehi diacritic:
([ނރ])(?![ަާިީުޫެޭޮޯް])

/([ނރ])(?![ަާިީުޫެޭޮޯް])/g
This regex uses:

A capturing group ([ނރ]) to match either ނ or ރ
A negative lookahead (?![ަާިީުޫެޭޮޯް]) that asserts the matched character isn't immediately followed by any Dhivehi diacritic

You can use it like this:
const text = "ނަރ ނާރީ ނު ރ ނއ ރް";
const regex = /([ނރ])(?![ަާިީުޫެޭޮޯް])/g;
const matches = [...text.matchAll(regex)];
console.log(matches.map(match => match[0]));
This will find all instances where ނ or ރ appear without being immediately followed by a diacritic.

...

write me js code to
take a text filecalled listRadheefW
catch all the words in there, that have a ނ or ރ  that does not have a diacritic on it
and output the results to a new file called, output_listRadheefW

Here's JavaScript code to process a text file and catch all words containing a ނ or ރ without a diacritic:

const fs = require('fs');

// Read the input file
fs.readFile('listRadheefW', 'utf8', (err, data) => {
  if (err) {
    console.error('Error reading file:', err);
    return;
  }

  // Split the content into words
  const words = data.split(/\s+/);

  // Regex to match ނ or ރ not followed by a diacritic
  const regex = /[ނރ](?![ަާިީުޫެޭޮޯް])/;

  // Filter words that contain ނ or ރ without a diacritic
  const matchedWords = words.filter(word => regex.test(word));

  // Write the results to the output file
  fs.writeFile('output_listRadheefW', matchedWords.join('\n'), 'utf8', (err) => {
    if (err) {
      console.error('Error writing to output file:', err);
      return;
    }
    console.log(`Processing complete. Found ${matchedWords.length} matching words.`);
  });
});

This code:

Reads the file 'listRadheefW'
Splits the content into individual words
Uses a regex to identify words containing ނ or ރ without a following diacritic
Writes the matching words to 'output_listRadheefW', one word per line

...

THIS POINT IS ENOUGH FOR MOSTLY 100% ACCURACY

54001 entries from 18/2/25 radheef
results in 6118 husnuunu/raa words
when duplicates and single letter are removed: 584 words

...

now what i want is, another script
that takes output_listRadheefW.txt
goes thru its list of words, which are words containing ނ or ރ without a following diacritic

what i want is, to remove all characters in that list of words, except that  ނ or ރ without a following diacritic, as well as 2 characters before and 2 characters after the  ނ or ރ without a following diacritic

Here's a script to process the output_listRadheefW.txt file and extract the characters you want:

const fs = require('fs');

// Read the input file
fs.readFile('output_listRadheefW.txt', 'utf8', (err, data) => {
  if (err) {
    console.error('Error reading file:', err);
    return;
  }

  // Split the content into words
  const words = data.split(/\s+/);
  
  // Array to store our results
  const results = [];

  // Process each word
  words.forEach(word => {
    // Regex to find ނ or ރ not followed by a diacritic
    const regex = /[ނރ](?![ަާިީުޫެޭޮޯް])/g;
    let match;
    
    // Find all occurrences in the word
    while ((match = regex.exec(word)) !== null) {
      const charIndex = match.index;
      const targetChar = match[0];
      
      // Calculate start and end indices for extraction
      const startIndex = Math.max(0, charIndex - 2);
      const endIndex = Math.min(word.length, charIndex + 2);
      
      // Extract the substring with 2 chars before and 2 chars after
      const extractedText = word.substring(startIndex, endIndex + 1);
      
      results.push(extractedText);
    }
  });

  // Write the results to a new file
  fs.writeFile('extracted_contexts.txt', results.join('\n'), 'utf8', (err) => {
    if (err) {
      console.error('Error writing to output file:', err);
      return;
    }
    console.log(`Processing complete. Extracted ${results.length} context segments.`);
  });
});

This script:

Reads the file 'output_listRadheefW.txt'
For each word, finds all occurrences of ނ or ރ not followed by a diacritic
For each occurrence, extracts the character itself plus 2 characters before and 2 characters after (if they exist)
Writes all extracted segments to a new file called 'extracted_contexts.txt'

...

then what i should do is, remove duplicate rows myself

...

give me regex to match the last character in a word

The regex to match the last character in a word is:
\w$

If you're working with JavaScript:
/\w$/

This will match the last alphanumeric character (letter, digit, or underscore) in a word.
If you need to match any character (not just alphanumeric) that appears at the end of a word or string, you can use:
.$

Or in JavaScript:
/.$/

If you're specifically looking to match the last character in each word of a text (where words are separated by spaces), you would need a slightly different approach using lookbehind and lookahead:
Copy(?<=\b\w*)\w(?=\s|$)

However, not all regex engines support lookbehind. For broader compatibility, you could use:
Copy\b\w\b|\w(?=\s|$)

...

from above, this would do:
.$

replace with nothing

remove duplicates

...

do the same for first character

The regex to match the first character in a word is:
^\w

If you're working with JavaScript:
/^\w/
This will match the first alphanumeric character (letter, digit, or underscore) at the beginning of a string.

If you need to match any character (not just alphanumeric) at the beginning of a string:
^.

Or in JavaScript:
/^./

If you want to match the first character of each word in a text (where words are separated by spaces), you can use:
\b\w

Or in JavaScript:
/\b\w/g

The \b is a word boundary that ensures you're matching the start of a word, and the \w matches the first alphanumeric character of that word. The g flag ensures you find all matches throughout the text.

...

for above, this would do:
^.

remove duplicates

...

regex to find a single character when thats all there is in a line

The regex to find a single character when it's the only thing on a line is:
^.$

In JavaScript:
/^.$/m
This pattern works by:

^ matches the start of a line
. matches any single character
$ matches the end of a line
The m flag (multiline) is important if you're working with multiple lines of text

This will match lines that consist of exactly one character and nothing else (no spaces, no other characters).

If you specifically want to match only lines with a single word character (letter, digit, or underscore):
^\w$

In JavaScript:
/^\w$/m

...

then go over them and prune the list further


*/
